---
title: refactor
date: 2017-02-09 16:53:10
tags: read
---

## 重构

- 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后现添加特性
- 重构前，先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力
- 重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易使可发现它。
- 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
- 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。


<!--more-->

## 重构原则

#### 何为重构

> **重构(名词)**：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本
>
> **重构(动词)**：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

#### 为何重构

- 重构改进软件设计
- 重构使软件更容易理解
- 重构帮助找到BUG
- 重构提高编程速度

#### 何时重构
**三次法则（事不过三，三则重构）**
- 添加功能时重构
- 修补错误时重构
- 复审代码时重构

## 代码的坏味道

- **Duplicated Code(重复代码)**

- **Long Method(过长函数)**

- **Large Class(过大的类)**

- **Long Parameter List(过长参数列)**

- **Divergent Change(发散式变化)**

  （如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了）

- **Shotgun Surgery(霰弹式修改)**

  （Shotgun Surgery类亿Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做许多小修改，你所面临的坏味道就是Shotgun Surgery）

- **Feature Envy(依恋情结)**

  （函数对某个类的兴趣高过对自己所处类的兴趣）

- **Data Clumps(数据泥团)**

  （两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。）

- **Primitive Obsession(基本类型偏执)**

  （对象技术的新手通常不愿意在小任务上运用小对象—像是结合数值和币种的money类、由一个超始值和一个结束值组成的range类、电话号码或邮政编码）

- **Switch Statements(switch惊悚现身)**

  （你常会发现同样的switch语句散布于不同地点。如果要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。）

- **Parallel Inheritance Hierarchies(平行继承体系)**

  （Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个类增加一个子类，必须也为另一相类增加一个子类。如果你发现某个继承体系的类名称前缀和别一个继承体系的类名称前缀完全相同，便是闻到了这种坏味道。）

- **Lazy Class(冗赘类)**

  （你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值其身价，它就应该消失。）

- **Speculative Generality(夸夸其谈未来性)**

  （企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。）

- **Temporary Field(令人迷惑的暂时字段)**

  （某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。）

- **Message Chains(过度耦合的消息链)**

  （向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求别一个对象……这就是消息链。采取这种方式，意味客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生变化，客户端就不得不做了相应修改。）

- **Middle Man(中间人)**

  （对象的基本特征之一就是封装—对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。你也许会看到某个类接口有一关的函数都委托给其他类，这样就是过度运用。）

- **Inappropriate Intimacy(狎昵关系)**

  （有时你会看到两个类过于亲密，花费太多时间去探究彼此的private成分。对于这样过分狎昵的类必须拆散。）

- **Alternative Classes with Different Interfaces(异曲同工的类)**

  （两个函数做同一件事，却有着不同的签名）

- **Incomplete Library Class(不完美的库类)**

- **Data Class(纯稚的数据类)**

  （它们拥有一些字段，以及用于访问、读写这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其它类过分细琐地操控着。对于那些不该被其他类修改的字段。请提示get/set）

- **Refused Bequest(被拒绝的遗赠)**

  (子类应该继承超类的函数和数据。但有时子类不需要继承一些无关的数据。这样一来，超类就只持有所有子类共享的东西。—所有超类都应该是抽象的)

- **Comments(过多的注释)**

  ​
## 构筑测试体系 

- 确保所有测试都完全自动化，让它们检查自己的测试结果。
- 一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间。
- 频繁地运行测试。每次编译请把测试也考虑进去—每天至少执行每个测试一次。
- 每当你收到bug报告，请先写一个单元测试来暴露这个bug。
- 编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。
- 考虑可能出错的边界条件，把测试火力集中在那儿。
- 当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常。
- 不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug。

## 重构列表

重构的基本技巧———小步前进，频繁测试